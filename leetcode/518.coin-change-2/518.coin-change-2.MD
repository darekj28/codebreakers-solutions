## Motivation
This problem lends itself to dynamic programming since it's very easy to solve the number of ways of creating an `amount` if you know the number of ways to create any amount smaller. A good approach for finding the pattern would be to try solving the problem when the `amount` to be created is small and the `coins` list is small. 

This problem is tricky because the state of our subproblem is dependent on two things: the `amount` and the number of coins we are using from `coins`, so there are sort of two layers to the problem. Let's take the following as an example: `amount` = 10 and `coins` = [1,5,10]. It's important to notice that the number of ways of generating the amount 10 isn't simply the number of ways to generate the amount 10 + number of ways to generate amount 9 + number of ways to generate amount 5 (or more formally, sol(n) != sum(solution(n-c) for all c in coins)). Many people jump to this conclusion since they naively concluded you can just add the "missing coin" c to the subproblem n-c, but you'll end up overcounting. For example, the number of ways to generate 9 is 2: [(1,1,1,1,1,1,1,1,1), (1,1,1,1,5)], the ways to generate 5 is 2: [(1,1,1,1,1), (5)], and the number of ways to generate 10 is 1: [(10)]. This leads to an incorrect solution of 5. You end up double counting the with five 1s and one 5 by adding 1 to (1,1,1,1,5) and adding 5 to (1,1,1,1,1). In order to avoid double counting, we can instead build our solution by first answer the question: how many ways can I build my `amount` n with only i coins, initializing i at 0 (our base case, you can only make the amount 0 in 1 way with no coins). 

More formally, the recurrence relation for this problem is solution(n,i) = sum(solution(n-c,i-1)) for all c in coins[:i]) and i in range(len(`coins`)). The relation holds since the set of ways we can generate the `amount` n with `coins[:i]` is equal all the ways we can generate n-c for all c in `coins[:i]` since we can reach the desired amount by adding an additional coin c to the set of coins that sum to amount-c AND we "force the order of the coins" as we "generate" the sums.

# Time Complexity: `O(n*c)`
The time complexity is `O(n*c)`  where n is the `amount` we are trying to generate and c is the number of `coins`.

# Space Complexity: `O(n)`
The space complexity is linear to the `amount` since we create a dp matrix to hold the solutions to the subproblems.